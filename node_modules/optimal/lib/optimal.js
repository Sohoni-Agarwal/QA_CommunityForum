"use strict";

exports.__esModule = true;
exports.default = optimal;

var _Builder = _interopRequireDefault(require("./Builder"));

var _isObject = _interopRequireDefault(require("./isObject"));

var _typeOf = _interopRequireDefault(require("./typeOf"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function buildAndCheck(blueprint, struct, options, parentPath) {
  if (options === void 0) {
    options = {};
  }

  if (parentPath === void 0) {
    parentPath = '';
  }

  var unknownFields = _extends({}, struct);

  var builtStruct = {};
  Object.keys(blueprint).forEach(function (baseKey) {
    var key = baseKey;
    var value = struct[key];
    var builder = blueprint[key];
    var path = String(parentPath ? parentPath + "." + key : key);

    if (builder instanceof _Builder.default || (0, _isObject.default)(builder) && builder.constructor.name.endsWith('Builder')) {
      builtStruct[key] = builder.runChecks(path, value, struct, options);
    } else if ("production" !== process.env.NODE_ENV) {
      throw new Error("Unknown blueprint for \"" + path + "\". Must be a builder.");
    }

    delete unknownFields[key];
  });

  if (options.unknown) {
    Object.assign(builtStruct, unknownFields);
  } else if ("production" !== process.env.NODE_ENV) {
    var unknownKeys = Object.keys(unknownFields);

    if (unknownKeys.length > 0) {
      var message = parentPath ? "Unknown \"" + parentPath + "\" fields" : 'Unknown fields';
      throw new Error(message + ": " + unknownKeys.join(', ') + ".");
    }
  }

  return builtStruct;
}

function optimal(struct, blueprint, options) {
  if (options === void 0) {
    options = {};
  }

  if ("production" !== process.env.NODE_ENV) {
    if (!(0, _isObject.default)(struct)) {
      throw new TypeError("Optimal requires a plain object, found " + (0, _typeOf.default)(struct) + ".");
    } else if (!(0, _isObject.default)(options)) {
      throw new TypeError('Optimal options must be a plain object.');
    } else if (!(0, _isObject.default)(blueprint)) {
      throw new TypeError('A blueprint is required.');
    }
  }

  return buildAndCheck(blueprint, struct, options, options.prefix);
}