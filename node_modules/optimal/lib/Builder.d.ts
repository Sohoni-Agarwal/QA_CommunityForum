import { SupportedType, CheckerCallback, CustomCallback, OptimalOptions, FuncOf } from './types';
export interface Check {
    args: unknown[];
    callback: CheckerCallback;
}
export default class Builder<T> {
    checks: Check[];
    currentStruct: object;
    defaultValue: T;
    deprecatedMessage: string;
    errorMessage: string;
    isNullable: boolean;
    isRequired: boolean;
    noErrorPrefix: boolean;
    options: OptimalOptions;
    type: SupportedType;
    constructor(type: SupportedType, defaultValue: T);
    /**
     * Add a checking function with optional arguments.
     */
    addCheck(checker: CheckerCallback, ...args: any[]): this;
    /**
     * Map a list of names that must be defined alongside this field.
     */
    and(...keys: string[]): this;
    /**
     * Validate that all fields have been defined.
     */
    checkAnd(path: string, value: T, otherKeys: string[]): void;
    /**
     * Validate the type of value.
     */
    checkType(path: string, value: T): void;
    /**
     * Set a callback to run custom logic.
     */
    custom(callback: CustomCallback<T>): this;
    /**
     * Validate the value using a custom callback.
     */
    checkCustom(path: string, value: T, callback: CustomCallback<T>): void;
    /**
     * Set a message to log when this field is present.
     */
    deprecate(message: string): this;
    /**
     * Throw an error if the condition is falsy.
     */
    invariant(condition: boolean, message: string, path?: string): void;
    /**
     * Return true if the value matches the default value and the builder is optional.
     */
    isOptionalDefault(value: any): boolean;
    /**
     * Return the current key from a path.
     */
    key(path: string): string;
    /**
     * Set a custom error message for all checks.
     */
    message(message: string): this;
    /**
     * Disallow null values.
     */
    notNullable(): Builder<NonNullable<T>>;
    /**
     * Allow null values.
     */
    nullable(): Builder<T | null>;
    /**
     * Mark a field as only the default value can be used.
     */
    only(): this;
    /**
     * Validate the value matches only the default value.
     */
    checkOnly(path: string, value: T): void;
    /**
     * Map a list of field names that must have at least 1 defined.
     */
    or(...keys: string[]): this;
    /**
     * Validate that at least 1 field is defined.
     */
    checkOr(path: string, value: T, otherKeys: string[]): void;
    /**
     * Require an object property to be explicitly defined.
     */
    required(state?: boolean): this;
    /**
     * Run all validation checks that have been enqueued.
     */
    runChecks(path: string, initialValue: T | undefined, struct: object, options?: OptimalOptions): T | null;
    /**
     * Return a human readable type name.
     */
    typeAlias(): string;
    /**
     * Map a list of field names that must not be defined alongside this field.
     */
    xor(...keys: string[]): this;
    /**
     * Validate that only 1 field is defined.
     */
    checkXor(path: string, value: T, otherKeys: string[]): void;
}
export declare function bool(defaultValue?: boolean): Builder<boolean>;
export declare function custom<T>(callback: CustomCallback<T>, defaultValue: T): Builder<T>;
export declare function func<T = FuncOf>(defaultValue?: T | null): Builder<T | null>;
