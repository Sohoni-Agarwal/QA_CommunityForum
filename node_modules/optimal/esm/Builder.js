function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import isObject from './isObject';

var Builder = function () {
  function Builder(type, defaultValue) {
    _defineProperty(this, "checks", []);

    _defineProperty(this, "currentStruct", {});

    _defineProperty(this, "defaultValue", void 0);

    _defineProperty(this, "deprecatedMessage", '');

    _defineProperty(this, "errorMessage", '');

    _defineProperty(this, "isNullable", false);

    _defineProperty(this, "isRequired", false);

    _defineProperty(this, "noErrorPrefix", false);

    _defineProperty(this, "options", {});

    _defineProperty(this, "type", void 0);

    if ("production" !== process.env.NODE_ENV) {
      this.invariant(typeof defaultValue !== 'undefined', "A default value for type \"" + type + "\" is required.");
      this.addCheck(this.checkType);
    }

    this.defaultValue = defaultValue;
    this.type = type;
  }

  var _proto = Builder.prototype;

  _proto.addCheck = function addCheck(checker) {
    if ("production" !== process.env.NODE_ENV) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      this.checks.push({
        args: args,
        callback: checker
      });
    }

    return this;
  };

  _proto.and = function and() {
    for (var _len2 = arguments.length, keys = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      keys[_key2] = arguments[_key2];
    }

    if ("production" !== process.env.NODE_ENV) {
      this.invariant(keys.length > 0, 'AND requires a list of field names.');
    }

    return this.addCheck(this.checkAnd, keys);
  };

  _proto.checkAnd = function checkAnd(path, value, otherKeys) {
    if ("production" !== process.env.NODE_ENV) {
      var keys = [this.key(path)].concat(otherKeys);
      var struct = this.currentStruct;
      var undefs = keys.filter(function (key) {
        return typeof struct[key] === 'undefined' || struct[key] === null;
      });

      if (undefs.length === keys.length) {
        return;
      }

      this.invariant(undefs.length === 0, "All of these fields must be defined: " + keys.join(', '));
    }
  };

  _proto.checkType = function checkType(path, value) {
    if ("production" !== process.env.NODE_ENV) {
      switch (this.type) {
        case 'array':
          this.invariant(Array.isArray(value), 'Must be an array.', path);
          break;

        case 'custom':
        case 'instance':
        case 'union':
          break;

        case 'object':
        case 'shape':
          this.invariant(isObject(value), 'Must be a plain object.', path);
          break;

        default:
          this.invariant(typeof value === this.type, "Must be a " + this.type + ".", path);
          break;
      }
    }
  };

  _proto.custom = function custom(callback) {
    if ("production" !== process.env.NODE_ENV) {
      this.invariant(typeof callback === 'function', 'Custom blueprints require a validation function.');
    }

    return this.addCheck(this.checkCustom, callback);
  };

  _proto.checkCustom = function checkCustom(path, value, callback) {
    if ("production" !== process.env.NODE_ENV) {
      try {
        callback(value, this.currentStruct);
      } catch (error) {
        this.invariant(false, error.message, path);
      }
    }
  };

  _proto.deprecate = function deprecate(message) {
    if ("production" !== process.env.NODE_ENV) {
      this.invariant(typeof message === 'string' && !!message, 'A non-empty string is required for deprecated messages.');
      this.deprecatedMessage = message;
    }

    return this;
  };

  _proto.invariant = function invariant(condition, message, path) {
    if (path === void 0) {
      path = '';
    }

    if ("production" !== process.env.NODE_ENV) {
      if (condition) {
        return;
      }

      var _this$options = this.options,
          file = _this$options.file,
          name = _this$options.name;
      var error = this.errorMessage || message;
      var prefix = '';

      if (path) {
        if (name) {
          prefix += "Invalid " + name + " field \"" + path + "\"";
        } else {
          prefix += "Invalid field \"" + path + "\"";
        }
      } else if (name) {
        prefix += name;
      }

      if (file) {
        prefix += " in " + file;
      }

      if (prefix && !this.noErrorPrefix) {
        throw new Error(prefix + ". " + error);
      } else {
        throw new Error(error);
      }
    }
  };

  _proto.isOptionalDefault = function isOptionalDefault(value) {
    return !this.isRequired && value === this.defaultValue;
  };

  _proto.key = function key(path) {
    var index = path.lastIndexOf('.');
    return index > 0 ? path.slice(index + 1) : path;
  };

  _proto.message = function message(_message) {
    if ("production" !== process.env.NODE_ENV) {
      this.invariant(typeof _message === 'string' && !!_message, 'A non-empty string is required for custom messages.');
      this.errorMessage = _message;
    }

    return this;
  };

  _proto.notNullable = function notNullable() {
    if ("production" !== process.env.NODE_ENV) {
      this.isNullable = false;
    }

    return this;
  };

  _proto.nullable = function nullable() {
    if ("production" !== process.env.NODE_ENV) {
      this.isNullable = true;
    }

    return this;
  };

  _proto.only = function only() {
    if ("production" !== process.env.NODE_ENV) {
      this.invariant(typeof this.defaultValue === this.type, "Only requires a default " + this.type + " value.");
    }

    return this.addCheck(this.checkOnly);
  };

  _proto.checkOnly = function checkOnly(path, value) {
    if ("production" !== process.env.NODE_ENV) {
      this.invariant(value === this.defaultValue, "Value may only be \"" + String(this.defaultValue) + "\".", path);
    }
  };

  _proto.or = function or() {
    for (var _len3 = arguments.length, keys = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      keys[_key3] = arguments[_key3];
    }

    if ("production" !== process.env.NODE_ENV) {
      this.invariant(keys.length > 0, 'OR requires a list of field names.');
    }

    return this.addCheck(this.checkOr, keys);
  };

  _proto.checkOr = function checkOr(path, value, otherKeys) {
    if ("production" !== process.env.NODE_ENV) {
      var keys = [this.key(path)].concat(otherKeys);
      var struct = this.currentStruct;
      var defs = keys.filter(function (key) {
        return typeof struct[key] !== 'undefined' && struct[key] !== null;
      });
      this.invariant(defs.length > 0, "At least one of these fields must be defined: " + keys.join(', '));
    }
  };

  _proto.required = function required(state) {
    if (state === void 0) {
      state = true;
    }

    if ("production" !== process.env.NODE_ENV) {
      this.isRequired = state;
    }

    return this;
  };

  _proto.runChecks = function runChecks(path, initialValue, struct, options) {
    var _this = this;

    if (options === void 0) {
      options = {};
    }

    this.currentStruct = struct;
    this.options = options;
    var value = initialValue;

    if (typeof value === 'undefined') {
      if (!this.isRequired) {
        value = this.defaultValue;
      } else if ("production" !== process.env.NODE_ENV) {
        this.invariant(false, 'Field is required and must be defined.', path);
      }
    } else if (this.deprecatedMessage) {
      if ("production" !== process.env.NODE_ENV) {
        console.info("Field \"" + path + "\" is deprecated. " + this.deprecatedMessage);
      }
    }

    if (value === null) {
      if (this.isNullable) {
        return value;
      }

      if ("production" !== process.env.NODE_ENV) {
        this.invariant(false, 'Null is not allowed.', path);
      }
    }

    if ("production" !== process.env.NODE_ENV) {
      this.checks.forEach(function (checker) {
        var _checker$callback;

        var result = (_checker$callback = checker.callback).call.apply(_checker$callback, [_this, path, value].concat(checker.args));

        if (typeof result !== 'undefined') {
          value = result;
        }
      });
    }

    return value;
  };

  _proto.typeAlias = function typeAlias() {
    return this.type;
  };

  _proto.xor = function xor() {
    for (var _len4 = arguments.length, keys = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      keys[_key4] = arguments[_key4];
    }

    if ("production" !== process.env.NODE_ENV) {
      this.invariant(keys.length > 0, 'XOR requires a list of field names.');
    }

    return this.addCheck(this.checkXor, keys);
  };

  _proto.checkXor = function checkXor(path, value, otherKeys) {
    if ("production" !== process.env.NODE_ENV) {
      var keys = [this.key(path)].concat(otherKeys);
      var struct = this.currentStruct;
      var defs = keys.filter(function (key) {
        return typeof struct[key] !== 'undefined' && struct[key] !== null;
      });
      this.invariant(defs.length === 1, "Only one of these fields may be defined: " + keys.join(', '));
    }
  };

  return Builder;
}();

export { Builder as default };
export function bool(defaultValue) {
  if (defaultValue === void 0) {
    defaultValue = false;
  }

  return new Builder('boolean', defaultValue);
}
export function custom(callback, defaultValue) {
  return new Builder('custom', defaultValue).custom(callback);
}
export function func(defaultValue) {
  if (defaultValue === void 0) {
    defaultValue = null;
  }

  return new Builder('function', defaultValue).nullable();
}