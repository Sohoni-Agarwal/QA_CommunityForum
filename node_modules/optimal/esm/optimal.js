function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

import Builder from './Builder';
import isObject from './isObject';
import typeOf from './typeOf';

function buildAndCheck(blueprint, struct, options, parentPath) {
  if (options === void 0) {
    options = {};
  }

  if (parentPath === void 0) {
    parentPath = '';
  }

  var unknownFields = _extends({}, struct);

  var builtStruct = {};
  Object.keys(blueprint).forEach(function (baseKey) {
    var key = baseKey;
    var value = struct[key];
    var builder = blueprint[key];
    var path = String(parentPath ? parentPath + "." + key : key);

    if (builder instanceof Builder || isObject(builder) && builder.constructor.name.endsWith('Builder')) {
      builtStruct[key] = builder.runChecks(path, value, struct, options);
    } else if ("production" !== process.env.NODE_ENV) {
      throw new Error("Unknown blueprint for \"" + path + "\". Must be a builder.");
    }

    delete unknownFields[key];
  });

  if (options.unknown) {
    Object.assign(builtStruct, unknownFields);
  } else if ("production" !== process.env.NODE_ENV) {
    var unknownKeys = Object.keys(unknownFields);

    if (unknownKeys.length > 0) {
      var message = parentPath ? "Unknown \"" + parentPath + "\" fields" : 'Unknown fields';
      throw new Error(message + ": " + unknownKeys.join(', ') + ".");
    }
  }

  return builtStruct;
}

export default function optimal(struct, blueprint, options) {
  if (options === void 0) {
    options = {};
  }

  if ("production" !== process.env.NODE_ENV) {
    if (!isObject(struct)) {
      throw new TypeError("Optimal requires a plain object, found " + typeOf(struct) + ".");
    } else if (!isObject(options)) {
      throw new TypeError('Optimal options must be a plain object.');
    } else if (!isObject(blueprint)) {
      throw new TypeError('A blueprint is required.');
    }
  }

  return buildAndCheck(blueprint, struct, options, options.prefix);
}