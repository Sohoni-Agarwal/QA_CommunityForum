function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import Builder from './Builder';
import typeOf from './typeOf';

var UnionBuilder = function (_Builder) {
  _inheritsLoose(UnionBuilder, _Builder);

  function UnionBuilder(builders, defaultValue) {
    var _this;

    _this = _Builder.call(this, 'union', defaultValue) || this;

    _defineProperty(_assertThisInitialized(_this), "builders", []);

    if ("production" !== process.env.NODE_ENV) {
      _this.invariant(Array.isArray(builders) && builders.length > 0 && builders.every(function (builder) {
        return builder instanceof Builder;
      }), 'A non-empty array of blueprints are required for a union.');

      _this.builders = builders;

      _this.addCheck(_this.checkUnions, builders);
    }

    return _this;
  }

  var _proto = UnionBuilder.prototype;

  _proto.checkUnions = function checkUnions(path, value, builders) {
    var _this2 = this;

    var nextValue = value;

    if ("production" !== process.env.NODE_ENV) {
      var keys = builders.map(function (builder) {
        return builder.typeAlias();
      }).join(', ');
      var type = typeOf(value);
      var errors = new Set();
      var passed = builders.some(function (builder) {
        if (builder.type === 'union') {
          _this2.invariant(false, 'Nested unions are not supported.', path);
        }

        try {
          if (type === builder.type || type === 'object' && builder.type === 'shape' || builder.type === 'custom') {
            builder.noErrorPrefix = true;
            nextValue = builder.runChecks(path, value, _this2.currentStruct, _this2.options);
            return true;
          }
        } catch (error) {
          errors.add(" - " + error.message + "\n");
        }

        return false;
      });
      var message = "Type must be one of: " + keys + ".";

      if (!passed && errors.size > 0) {
        message += " Received " + type + " with the following invalidations:\n";
        errors.forEach(function (error) {
          message += error;
        });
      }

      this.invariant(passed, message.trim(), path);
    }

    return nextValue;
  };

  _proto.typeAlias = function typeAlias() {
    return this.builders.map(function (builder) {
      return builder.typeAlias();
    }).join(' | ');
  };

  return UnionBuilder;
}(Builder);

export { UnionBuilder as default };
export function union(builders, defaultValue) {
  return new UnionBuilder(builders, defaultValue);
}